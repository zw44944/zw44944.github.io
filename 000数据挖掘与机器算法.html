<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 7.3.0">
  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">


<link rel="stylesheet" href="/lib/font-awesome/css/all.min.css">

<script id="hexo-configurations">
    var NexT = window.NexT || {};
    var CONFIG = {"hostname":"example.com","root":"/","scheme":"Muse","version":"7.8.0","exturl":false,"sidebar":{"position":"left","display":"post","padding":18,"offset":12,"onmobile":false},"copycode":{"enable":false,"show_result":false,"style":null},"back2top":{"enable":true,"sidebar":false,"scrollpercent":false},"bookmark":{"enable":false,"color":"#222","save":"auto"},"fancybox":false,"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"algolia":{"hits":{"per_page":10},"labels":{"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}},"localsearch":{"enable":false,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false},"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}}};
  </script>

  <meta name="description" content="线性代数矩阵乘法满足：M*N   N*P &#x3D; M*P  标量*向量 &#x3D; 向量 行*列 &#x3D; 标量 列*行 &#x3D; 矩阵 列*矩阵 &#x3D;未定义 矩阵*列 &#x3D; 列 行*矩阵 &#x3D; 行 矩阵 * 行 &#x3D; 矩阵 * 行的转置 &#x3D; 列  企业中真实的数据挖掘和应用流程 数据挖掘方法论 机器学习领域可以分为两个子领域，监督学习和非监督学习。">
<meta property="og:type" content="website">
<meta property="og:title" content="zw python">
<meta property="og:url" content="http://example.com/000%E6%95%B0%E6%8D%AE%E6%8C%96%E6%8E%98%E4%B8%8E%E6%9C%BA%E5%99%A8%E7%AE%97%E6%B3%95.html">
<meta property="og:site_name" content="zw python">
<meta property="og:description" content="线性代数矩阵乘法满足：M*N   N*P &#x3D; M*P  标量*向量 &#x3D; 向量 行*列 &#x3D; 标量 列*行 &#x3D; 矩阵 列*矩阵 &#x3D;未定义 矩阵*列 &#x3D; 列 行*矩阵 &#x3D; 行 矩阵 * 行 &#x3D; 矩阵 * 行的转置 &#x3D; 列  企业中真实的数据挖掘和应用流程 数据挖掘方法论 机器学习领域可以分为两个子领域，监督学习和非监督学习。">
<meta property="og:locale" content="en_US">
<meta property="og:image" content="https://s2.loli.net/2024/11/13/GLo3Ke54y2HgZuk.png">
<meta property="og:image" content="https://s2.loli.net/2024/11/13/OwY9PBojkNS4Jnb.png">
<meta property="og:image" content="https://s2.loli.net/2024/11/13/mvEQgk2rPZUKRzW.png">
<meta property="article:published_time" content="2024-11-21T03:19:15.599Z">
<meta property="article:modified_time" content="2024-11-20T07:54:25.841Z">
<meta property="article:author" content="zw">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://s2.loli.net/2024/11/13/GLo3Ke54y2HgZuk.png">

<link rel="canonical" href="http://example.com/000%E6%95%B0%E6%8D%AE%E6%8C%96%E6%8E%98%E4%B8%8E%E6%9C%BA%E5%99%A8%E7%AE%97%E6%B3%95">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome : false,
    isPost : false,
    lang   : 'en'
  };
</script>

  <title> | zw python
</title>
  






  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

</head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="container use-motion">
    <div class="headband"></div>

    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="Toggle navigation bar">
      <span class="toggle-line toggle-line-first"></span>
      <span class="toggle-line toggle-line-middle"></span>
      <span class="toggle-line toggle-line-last"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <span class="logo-line-before"><i></i></span>
      <h1 class="site-title">zw python</h1>
      <span class="logo-line-after"><i></i></span>
    </a>
      <p class="site-subtitle" itemprop="description">zw</p>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
    </div>
  </div>
</div>




<nav class="site-nav">
  <ul id="menu" class="main-menu menu">
        <li class="menu-item menu-item-home">

    <a href="/" rel="section">Home</a>

  </li>
        <li class="menu-item menu-item-tags">

    <a href="/tags/" rel="section">Tags</a>

  </li>
        <li class="menu-item menu-item-categories">

    <a href="/categories/" rel="section">Categories</a>

  </li>
        <li class="menu-item menu-item-archives">

    <a href="/archives/" rel="section">Archives</a>

  </li>
  </ul>
</nav>




</div>
    </header>

    
  <div class="back-to-top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>


    <main class="main">
      <div class="main-inner">
        <div class="content-wrap">
          
  
  

          <div class="content page posts-expand">
            

    
    
    
    <div class="post-block" lang="en">
      <header class="post-header">

<h1 class="post-title" itemprop="name headline">
</h1>

<div class="post-meta">
  

</div>

</header>

      
      
      
      <div class="post-body">
          <h3 id="线性代数"><a href="#线性代数" class="headerlink" title="线性代数"></a>线性代数</h3><p>矩阵乘法满足：<code>M*N   N*P = M*P</code></p>
<ul>
<li>标量*向量 &#x3D; 向量</li>
<li>行*列 &#x3D; 标量</li>
<li>列*行 &#x3D; 矩阵</li>
<li>列*矩阵 &#x3D;未定义</li>
<li>矩阵*列 &#x3D; 列</li>
<li>行*矩阵 &#x3D; 行</li>
<li>矩阵 * 行 &#x3D; 矩阵 * 行的转置 &#x3D; 列</li>
</ul>
<h3 id="企业中真实的数据挖掘和应用流程"><a href="#企业中真实的数据挖掘和应用流程" class="headerlink" title="企业中真实的数据挖掘和应用流程"></a>企业中真实的数据挖掘和应用流程</h3><p><img src="https://s2.loli.net/2024/11/13/GLo3Ke54y2HgZuk.png" alt=".png"></p>
<h3 id="数据挖掘方法论"><a href="#数据挖掘方法论" class="headerlink" title="数据挖掘方法论"></a>数据挖掘方法论</h3><p><img src="https://s2.loli.net/2024/11/13/OwY9PBojkNS4Jnb.png" alt=".png"></p>
<p><strong>机器学习领域可以分为两个子领域，监督学习和非监督学习。监督学习就是有标签的，通过给定的训练数据得到规律来进行分类。无监督学习就是让一个不认识猫狗的小孩进行猫狗分类。</strong></p>
<h3 id="数据挖掘六大任务对应的机器学习算法"><a href="#数据挖掘六大任务对应的机器学习算法" class="headerlink" title="数据挖掘六大任务对应的机器学习算法"></a>数据挖掘六大任务对应的机器学习算法</h3><p><img src="https://s2.loli.net/2024/11/13/mvEQgk2rPZUKRzW.png" alt=".png"></p>
<p>常见的机器学习算法：</p>
<ul>
<li><p>线性回归</p>
</li>
<li><p>逻辑回归</p>
</li>
<li><p>k近邻算法</p>
</li>
<li><p>向量机 </p>
</li>
<li><p>决策树</p>
</li>
<li><p>随机森林</p>
</li>
<li><p>无监督算法</p>
</li>
<li><p>聚类  k均值聚类</p>
</li>
<li><p>降维  主成分分析</p>
</li>
<li><p>贝叶斯</p>
</li>
<li><p>adaboost</p>
</li>
</ul>
<h3 id="numpy"><a href="#numpy" class="headerlink" title="numpy"></a>numpy</h3><p>NumPy 最重要的一个特点是其 N 维数组对象 ndarray，它是一系列同类型数据的集合，以 0 下标为开始进行集合中元素的索引。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">numpy.array(<span class="built_in">object</span>, dtype = <span class="literal">None</span>, copy = <span class="literal">True</span>, order = <span class="literal">None</span>, subok = <span class="literal">False</span>, ndmin = <span class="number">0</span>)</span><br><span class="line">numpy.arange(start, stop, step, dtype)</span><br></pre></td></tr></table></figure>

<p>广播特性：形状不相同的两个数组运算时，如果其中一个数组的维度为1，可以通过广播机制将这个数组扩展成另一个形状的数组。</p>
<p>numpy的乘除和矩阵的乘除不一样</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#修改数组形状</span></span><br><span class="line">numpy.reshape(arr, newshape, order=<span class="string">&#x27;C&#x27;</span>)</span><br><span class="line"><span class="comment">#展平数组</span></span><br><span class="line">ndarray.flatten(order=<span class="string">&#x27;C&#x27;</span>)</span><br><span class="line"><span class="comment">#转置数组</span></span><br><span class="line">ndarray.T</span><br><span class="line"><span class="comment">#四舍五入</span></span><br><span class="line">numpy.around(a,decimals)</span><br><span class="line"><span class="comment">#向下取整</span></span><br><span class="line">numpy.floor()</span><br><span class="line"><span class="comment">#向上取整</span></span><br><span class="line">numpy.ceil()</span><br><span class="line"><span class="comment">#加减乘除 形状一样或符合广播</span></span><br><span class="line"> add()，subtract()，multiply() 和 divide()</span><br><span class="line"> <span class="comment">#排序函数</span></span><br><span class="line"> numpy.sort(a, axis, kind, order)</span><br></pre></td></tr></table></figure>



<h3 id="pandas"><a href="#pandas" class="headerlink" title="pandas"></a>pandas</h3><p>两个主要数据结构：Series和DataFrame</p>
<ul>
<li>Series：任何数据类型的一维数组，数组里数据类型是一致的，由数据和索引组成。</li>
<li>DataFrame：二维标记的数据结构，同列数据类型一致。</li>
</ul>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">pd.Series(&#123;<span class="string">&#x27;a&#x27;</span>:<span class="number">0</span>,<span class="string">&#x27;b&#x27;</span>:<span class="number">1</span>,<span class="string">&#x27;c&#x27;</span>:<span class="number">2</span>&#125;,index=[<span class="string">&#x27;c&#x27;</span>,<span class="string">&#x27;a&#x27;</span>,<span class="string">&#x27;b&#x27;</span>])</span><br><span class="line">pd.Series([<span class="number">0.1</span>,<span class="number">0.3</span>,<span class="number">0.5</span>],index=[<span class="string">&#x27;a&#x27;</span>,<span class="string">&#x27;b&#x27;</span>,<span class="string">&#x27;c&#x27;</span>],dtype=<span class="string">&#x27;int8&#x27;</span>)</span><br><span class="line">pd.Series(np.random.randn(<span class="number">4</span>),index=[<span class="string">&#x27;a&#x27;</span>,<span class="string">&#x27;b&#x27;</span>,<span class="string">&#x27;c&#x27;</span>,<span class="string">&#x27;d&#x27;</span>])</span><br><span class="line"></span><br><span class="line">pd.DataFrame(&#123;<span class="string">&#x27;b&#x27;</span>:[<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>],<span class="string">&#x27;a&#x27;</span>:np.arange(<span class="number">4</span>)&#125;,columns=[<span class="string">&#x27;b&#x27;</span>,<span class="string">&#x27;a&#x27;</span>,<span class="string">&#x27;e&#x27;</span>])</span><br><span class="line">pd.DataFrame(np.random.randn(<span class="number">5</span>,<span class="number">4</span>),index=<span class="built_in">list</span>(<span class="string">&#x27;abcde&#x27;</span>),columns=<span class="built_in">list</span>(<span class="string">&#x27;colu&#x27;</span>))</span><br></pre></td></tr></table></figure>

<h5 id="数据查看"><a href="#数据查看" class="headerlink" title="数据查看"></a>数据查看</h5><h6 id="数据抽样"><a href="#数据抽样" class="headerlink" title="数据抽样"></a>数据抽样</h6><ul>
<li>sample</li>
<li>head</li>
<li>tail</li>
</ul>
<h6 id="数据属性"><a href="#数据属性" class="headerlink" title="数据属性"></a>数据属性</h6><ul>
<li>shape</li>
<li>index</li>
<li>columns</li>
<li>dtype</li>
<li>Values</li>
<li>info</li>
</ul>
<h6 id="数据特征查看"><a href="#数据特征查看" class="headerlink" title="数据特征查看"></a>数据特征查看</h6><ul>
<li>unique</li>
<li>values_count</li>
<li>is_null</li>
<li>duplicated</li>
</ul>
<h6 id="统计信息查看"><a href="#统计信息查看" class="headerlink" title="统计信息查看"></a>统计信息查看</h6><ul>
<li>describe</li>
<li>argmin</li>
</ul>
<h5 id="数据选择"><a href="#数据选择" class="headerlink" title="数据选择"></a>数据选择</h5><h6 id="行列表示方法"><a href="#行列表示方法" class="headerlink" title="行列表示方法"></a>行列表示方法</h6><ul>
<li>名称</li>
<li>位置</li>
</ul>
<h6 id="切片表示方法"><a href="#切片表示方法" class="headerlink" title="切片表示方法"></a>切片表示方法</h6><ul>
<li>单值切片</li>
<li>列表切片</li>
<li>连续切片</li>
<li>布尔切片</li>
</ul>
<h6 id="行列抽取"><a href="#行列抽取" class="headerlink" title="行列抽取"></a>行列抽取</h6><ul>
<li>行模式</li>
<li>列模式</li>
<li>行列模式  索引名称loc[ ],索引位置iloc[ ]</li>
<li>值模式</li>
</ul>
<h6 id="其他选择方式"><a href="#其他选择方式" class="headerlink" title="其他选择方式"></a>其他选择方式</h6><ul>
<li>select_dtypes</li>
<li>filter</li>
</ul>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 选择指定的列</span></span><br><span class="line">df[<span class="string">&#x27;column_name&#x27;</span>]</span><br><span class="line"></span><br><span class="line"><span class="comment"># 通过标签选择数据</span></span><br><span class="line">df.loc[row_index, column_name]</span><br><span class="line"></span><br><span class="line"><span class="comment"># 通过位置选择数据</span></span><br><span class="line">df.iloc[row_index, column_index]</span><br><span class="line"></span><br><span class="line"><span class="comment"># 通过标签或位置选择数据</span></span><br><span class="line">df.ix[row_index, column_name]</span><br><span class="line"></span><br><span class="line"><span class="comment"># 选择指定的列</span></span><br><span class="line">df.<span class="built_in">filter</span>(items=[<span class="string">&#x27;column_name1&#x27;</span>, <span class="string">&#x27;column_name2&#x27;</span>])</span><br><span class="line"></span><br><span class="line"><span class="comment"># 选择列名匹配正则表达式的列</span></span><br><span class="line">df.<span class="built_in">filter</span>(regex=<span class="string">&#x27;regex&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 随机选择 n 行数据</span></span><br><span class="line">df.sample(n=<span class="number">5</span></span><br></pre></td></tr></table></figure>



<h5 id="数据读取与清洗"><a href="#数据读取与清洗" class="headerlink" title="数据读取与清洗"></a>数据读取与清洗</h5><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">DataFrame.dropna(axis=<span class="number">0</span>, how=<span class="string">&#x27;any&#x27;</span>, thresh=<span class="literal">None</span>, subset=<span class="literal">None</span>, inplace=<span class="literal">False</span>)</span><br></pre></td></tr></table></figure>

<ul>
<li>axis：默认为 <strong>0</strong>，表示逢空值剔除整行，如果设置参数 <strong>axis＝1</strong> 表示逢空值去掉整列。</li>
<li>how：默认为 <strong>‘any’</strong> 如果一行（或一列）里任何一个数据有出现 NA 就去掉整行，如果设置 <strong>how&#x3D;’all’</strong> 一行（或列）都是 NA 才去掉这整行。</li>
<li>thresh：设置需要多少非空值的数据才可以保留下来的。</li>
<li>subset：设置想要检查的列。如果是多个列，可以使用列名的 list 作为参数。</li>
<li>inplace：如果设置 True，将计算得到的值直接覆盖之前的值并返回 None，修改的是源数据。</li>
</ul>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> pandas <span class="keyword">as</span> pd</span><br><span class="line"><span class="comment">#计算均值、中值、中位数值并替换 mean()、median()、mode()</span></span><br><span class="line">df = pd.read_csv(<span class="string">&#x27;property-data.csv&#x27;</span>)</span><br><span class="line"></span><br><span class="line">x = df[<span class="string">&quot;ST_NUM&quot;</span>].mean()</span><br><span class="line"></span><br><span class="line">df[<span class="string">&quot;ST_NUM&quot;</span>].fillna(x, inplace = <span class="literal">True</span>)</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span> (df.to_string())</span><br><span class="line"></span><br><span class="line"><span class="comment"># 删除包含缺失值的行或列</span></span><br><span class="line">df.dropna()</span><br><span class="line"></span><br><span class="line"><span class="comment"># 将缺失值替换为指定的值</span></span><br><span class="line">df.fillna(<span class="number">0</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 将指定值替换为新值</span></span><br><span class="line">df.replace(<span class="string">&#x27;old_value&#x27;</span>, <span class="string">&#x27;new_value&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 检查是否有重复的数据</span></span><br><span class="line">df.duplicated()</span><br><span class="line"></span><br><span class="line"><span class="comment"># 删除重复的数据</span></span><br><span class="line">df.drop_duplicates()</span><br></pre></td></tr></table></figure>



<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> pandas <span class="keyword">as</span> pd</span><br><span class="line"></span><br><span class="line"><span class="comment"># 第三个日期格式错误</span></span><br><span class="line">data = &#123;</span><br><span class="line">  <span class="string">&quot;Date&quot;</span>: [<span class="string">&#x27;2020/12/01&#x27;</span>, <span class="string">&#x27;2020/12/02&#x27;</span> , <span class="string">&#x27;20201226&#x27;</span>],</span><br><span class="line">  <span class="string">&quot;duration&quot;</span>: [<span class="number">50</span>, <span class="number">40</span>, <span class="number">45</span>]</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">df = pd.DataFrame(data, index = [<span class="string">&quot;day1&quot;</span>, <span class="string">&quot;day2&quot;</span>, <span class="string">&quot;day3&quot;</span>])</span><br><span class="line"></span><br><span class="line">df[<span class="string">&#x27;Date&#x27;</span>] = pd.to_datetime(df[<span class="string">&#x27;Date&#x27;</span>], <span class="built_in">format</span>=<span class="string">&#x27;mixed&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(df.to_string())</span><br></pre></td></tr></table></figure>



<h6 id="读取数据"><a href="#读取数据" class="headerlink" title="读取数据"></a>读取数据</h6><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> pandas <span class="keyword">as</span> pd</span><br><span class="line"></span><br><span class="line"><span class="comment"># 从 CSV 文件中读取数据</span></span><br><span class="line">df = pd.read_csv(<span class="string">&#x27;data.csv&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 从 Excel 文件中读取数据</span></span><br><span class="line">df = pd.read_excel(<span class="string">&#x27;data.xlsx&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 从 SQL 数据库中读取数据</span></span><br><span class="line"><span class="keyword">import</span> sqlite3</span><br><span class="line">conn = sqlite3.connect(<span class="string">&#x27;database.db&#x27;</span>)</span><br><span class="line">df = pd.read_sql(<span class="string">&#x27;SELECT * FROM table_name&#x27;</span>, conn)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 从 JSON 字符串中读取数据</span></span><br><span class="line">json_string = <span class="string">&#x27;&#123;&quot;name&quot;: &quot;John&quot;, &quot;age&quot;: 30, &quot;city&quot;: &quot;New York&quot;&#125;&#x27;</span></span><br><span class="line">df = pd.read_json(json_string)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 从 HTML 页面中读取数据</span></span><br><span class="line">url = <span class="string">&#x27;https://www.runoob.com&#x27;</span></span><br><span class="line">dfs = pd.read_html(url)</span><br><span class="line">df = dfs[<span class="number">0</span>] <span class="comment"># 选择第一个数据框</span></span><br></pre></td></tr></table></figure>

<h6 id="数据排序"><a href="#数据排序" class="headerlink" title="数据排序"></a>数据排序</h6><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 按照指定列的值排序</span></span><br><span class="line">df.sort_values(<span class="string">&#x27;column_name&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 按照多个列的值排序</span></span><br><span class="line">df.sort_values([<span class="string">&#x27;column_name1&#x27;</span>, <span class="string">&#x27;column_name2&#x27;</span>], ascending=[<span class="literal">True</span>, <span class="literal">False</span>])</span><br><span class="line"></span><br><span class="line"><span class="comment"># 按照索引排序</span></span><br><span class="line">df.sort_index()</span><br><span class="line"></span><br><span class="line"><span class="comment"># 按照指定列进行分组</span></span><br><span class="line">df.groupby(<span class="string">&#x27;column_name&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 对分组后的数据进行聚合操作</span></span><br><span class="line">df.aggregate(<span class="string">&#x27;function_name&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 生成透视表</span></span><br><span class="line">df.pivot_table(values=<span class="string">&#x27;value&#x27;</span>, index=<span class="string">&#x27;index_column&#x27;</span>, columns=<span class="string">&#x27;column_name&#x27;</span>, aggfunc=<span class="string">&#x27;function_name&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 将多个数据框按照行或列进行合并</span></span><br><span class="line">df = pd.concat([df1, df2])</span><br><span class="line"></span><br><span class="line"><span class="comment"># 按照指定列将两个数据框进行合并</span></span><br><span class="line">df = pd.merge(df1, df2, on=<span class="string">&#x27;column_name&#x27;</span>)</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>



<h3 id="Matplotlib"><a href="#Matplotlib" class="headerlink" title="Matplotlib"></a>Matplotlib</h3><h3 id="scikit-learn"><a href="#scikit-learn" class="headerlink" title="scikit-learn"></a>scikit-learn</h3><h3 id="orange"><a href="#orange" class="headerlink" title="orange"></a>orange</h3><h3 id="Xgboost"><a href="#Xgboost" class="headerlink" title="Xgboost"></a>Xgboost</h3><h3 id="特征操作"><a href="#特征操作" class="headerlink" title="特征操作"></a>特征操作</h3><h4 id="特征构造常用方法"><a href="#特征构造常用方法" class="headerlink" title="特征构造常用方法"></a>特征构造常用方法</h4><p>文本数据使用词向量法，图像数据是使用像素值，表格数据使用数字</p>
<h4 id="特征转换之无量纲化"><a href="#特征转换之无量纲化" class="headerlink" title="特征转换之无量纲化"></a>特征转换之无量纲化</h4><p>无量纲化：使不同规格尺度的数据转换到同一规格尺度。</p>
<p>标准化：把原始的连续型变量转换为均值为0，标准差为1的变量。</p>
<p>区间缩放法：把原始的连续型变量转换为范围在[0-1]之间的变量。</p>
<h4 id="特征转换之数据变换"><a href="#特征转换之数据变换" class="headerlink" title="特征转换之数据变换"></a>特征转换之数据变换</h4><p>数据变换：通过函数变换改变元数据的分布。</p>
<ul>
<li>变换后更便捷的发现数据之间的关系：从没有关系变成有关系</li>
<li>很多数据呈现严重的偏态分布（很多偏小的值聚集在一起），变换之后差异可以拉开</li>
<li>让数据符合模型理论所需要的假设，然后对其分析，例如变换后数据呈现正态分布</li>
</ul>
<p><strong>常用的数据变换方法</strong></p>
<ul>
<li>log变换</li>
<li>box-cox变换：自动寻找最佳正态分布变换函数的方法</li>
</ul>
<h4 id="特征转换之离散型变换"><a href="#特征转换之离散型变换" class="headerlink" title="特征转换之离散型变换"></a>特征转换之离散型变换</h4><p>连续变量离散化：把连续型的数值切割为少数的一些区间，例如年龄值切割为5个年龄段</p>
<ul>
<li>方便探索数据分布和相关性，例如直方图，交叉表</li>
<li>特征离散后可以减轻异常数据对模型的影响，增强模型稳定，简化模型复杂度，降低过拟合风险。</li>
</ul>
<h4 id="特征转换之类别变量编码"><a href="#特征转换之类别变量编码" class="headerlink" title="特征转换之类别变量编码"></a>特征转换之类别变量编码</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#独热编码</span></span><br><span class="line"><span class="keyword">import</span> pandas <span class="keyword">as</span> pd</span><br><span class="line">trade = pd.read_csv()</span><br><span class="line">trade[<span class="string">&#x27;date&#x27;</span>] = pd.to_datetime(trade[<span class="string">&#x27;date&#x27;</span>])</span><br><span class="line">RFM = trade.groupby(<span class="string">&#x27;Cardid&#x27;</span>).agg(&#123;<span class="string">&#x27;date&#x27;</span>:<span class="string">&#x27;max&#x27;</span>,<span class="string">&#x27;carid&#x27;</span>:<span class="string">&#x27;count&#x27;</span>,<span class="string">&#x27;amount&#x27;</span>:<span class="string">&#x27;sum&#x27;</span>&#125;)</span><br><span class="line">RFM.head(<span class="number">10</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">#使用pandas</span></span><br><span class="line">onehot = pd.get_dummies(RFM[<span class="string">&#x27;carid&#x27;</span>],drop_first = <span class="literal">False</span>,prefix=<span class="string">&#x27;Freq&#x27;</span>)</span><br><span class="line">onehot.head()</span><br><span class="line"></span><br><span class="line"><span class="comment">#使用sklearn OneHotEncoder</span></span><br><span class="line"><span class="keyword">from</span> sklearn <span class="keyword">import</span> preprocessing</span><br><span class="line">onehot = preprocessing.OneHotEncoder()</span><br><span class="line">Freq = RFM[<span class="string">&#x27;carid&#x27;</span>].values.reshape(-<span class="number">1</span>,<span class="number">1</span>)</span><br><span class="line">onehot.fit(Freq)</span><br><span class="line">Freq_onehot = onehot.transform(Freq).toarray()</span><br><span class="line">Freq_onehot</span><br></pre></td></tr></table></figure>



<h4 id="特征转换之缺失值处理"><a href="#特征转换之缺失值处理" class="headerlink" title="特征转换之缺失值处理"></a>特征转换之缺失值处理</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> pandas <span class="keyword">as</span> pd</span><br><span class="line">titanic = pd.read_csv()</span><br><span class="line">titanic.info()</span><br><span class="line"></span><br><span class="line"><span class="comment">#均值填充</span></span><br><span class="line">age_mean = <span class="built_in">round</span>(titanic[<span class="string">&#x27;age&#x27;</span>].mean())</span><br><span class="line">titanic[<span class="string">&#x27;age&#x27;</span>].fillna(age_mean,inplace=<span class="literal">True</span>)</span><br><span class="line">titanic.info()</span><br><span class="line"></span><br><span class="line"><span class="comment">#构造缺失值的标志变量</span></span><br><span class="line">titanic[<span class="string">&#x27;age_ismissing&#x27;</span>] = <span class="number">0</span></span><br><span class="line">titanic.loc[titanic[<span class="string">&#x27;age&#x27;</span>].isnull(),<span class="string">&#x27;age_ismissing&#x27;</span>] = <span class="number">1</span></span><br><span class="line">titanic[<span class="string">&#x27;age_ismissing&#x27;</span>].value_counts()</span><br></pre></td></tr></table></figure>



<h4 id="特征转换之特征组合"><a href="#特征转换之特征组合" class="headerlink" title="特征转换之特征组合"></a>特征转换之特征组合</h4><p>目的：通过特征组合构建出更多更好的特征，提升模型精度。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> pandas <span class="keyword">as</span> pd</span><br><span class="line">titanic = pd.read_csv()</span><br><span class="line"><span class="comment">#组合特征</span></span><br><span class="line">Titanic[<span class="string">&#x27;sex_pclass_combo&#x27;</span>] = titanic[<span class="string">&#x27;sex&#x27;</span>] + <span class="string">&#x27;_pclass_&#x27;</span> + titanic[<span class="string">&#x27;pclass&#x27;</span>].astype(<span class="built_in">str</span>)</span><br><span class="line"></span><br><span class="line">titanic.sex_pclass_combo.value_counts()</span><br></pre></td></tr></table></figure>

<h4 id="数据降维"><a href="#数据降维" class="headerlink" title="数据降维"></a>数据降维</h4><p>降维：在尽量少减少信息量的前提下，采用某种映射方法（函数），把原来的高维数据（变量多）映射为低维数据（变量少）</p>
<h5 id="主成分分析原理："><a href="#主成分分析原理：" class="headerlink" title="主成分分析原理："></a>主成分分析原理：</h5><p>通过某种线性投影，将高维的数据映射到低维空间中表示，并期望在所投影的维度上数据的方差最大。使用较少的数据维度，尽量保留住最多的数据信息。</p>
<h5 id="PCA操作流程："><a href="#PCA操作流程：" class="headerlink" title="PCA操作流程："></a>PCA操作流程：</h5><ol>
<li>特征变量分别减去各自的均值</li>
<li>求特征变量的协方差矩阵</li>
<li>求协方差的特征值和特征向量</li>
<li>将特征值按照从大到小的顺序排序，选择其中最大的k（1）个，然后将其对应的k（1）个特征向量分别作为列向量组成特征向量矩阵。</li>
<li>将样本点投影到选取的特征向量上，得到最终降维后的新维度</li>
</ol>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> sklearn <span class="keyword">import</span> datasets</span><br><span class="line"></span><br><span class="line">iris = datasets.load_iris()</span><br><span class="line">X = iris.data</span><br><span class="line">y = iris.target</span><br><span class="line"></span><br><span class="line"><span class="keyword">from</span> sklearn.decomposition <span class="keyword">import</span> PCA</span><br><span class="line"><span class="comment"># sklearn.decomposition.PCA(n_components,copy=True,whiten=False)</span></span><br><span class="line"><span class="comment">#n_components:主成分个数</span></span><br><span class="line"><span class="comment">#copy 表示在运行算法时，是否将原始训练数据复制一份，默认为true</span></span><br><span class="line"><span class="comment">#whiten:白花，使得每个特征具有相同的方差，默认为False</span></span><br><span class="line">pca = PCA(n_components=<span class="number">3</span>)</span><br><span class="line">pca.fit(X)</span><br><span class="line">X_new = pca.transform(X)</span><br><span class="line"><span class="comment">#fit_transform，可以替代fit和transform(X)</span></span><br><span class="line">X_new = pca.fit_transform(X)</span><br><span class="line"></span><br><span class="line"><span class="comment">#主成分解释方差占比</span></span><br><span class="line"><span class="built_in">print</span> pca.explained_variance_ratio_</span><br><span class="line"><span class="built_in">print</span> pca.explained_variance</span><br><span class="line"></span><br><span class="line"><span class="comment">#pca降维后可视化</span></span><br><span class="line"><span class="keyword">import</span> matplotlib.pyplot <span class="keyword">as</span> plt</span><br><span class="line">%matplotlib inline</span><br><span class="line">plt.scatter(X_new[:,<span class="number">0</span>],X_new[:<span class="number">1</span>],marker=<span class="string">&#x27;o&#x27;</span>,c=y)</span><br><span class="line">plt.show()</span><br></pre></td></tr></table></figure>







<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> pandas <span class="keyword">as</span> pd</span><br><span class="line">trade = pd.read_csv()</span><br><span class="line">trade[<span class="string">&#x27;date&#x27;</span>] = pd.to_datetime(trade[<span class="string">&#x27;date&#x27;</span>])</span><br><span class="line">RFM = trade.groupby(<span class="string">&#x27;Cardid&#x27;</span>).agg(&#123;<span class="string">&#x27;date&#x27;</span>:<span class="string">&#x27;max&#x27;</span>,<span class="string">&#x27;carid&#x27;</span>:<span class="string">&#x27;count&#x27;</span>,<span class="string">&#x27;amount&#x27;</span>:<span class="string">&#x27;sum&#x27;</span>&#125;)</span><br><span class="line">RFM.head(<span class="number">10</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">#数据标准化</span></span><br><span class="line"><span class="keyword">from</span> sklearn <span class="keyword">import</span> preprocessing</span><br><span class="line">std = preprocessing.StandardScaler()</span><br><span class="line">amount = RFM[<span class="string">&#x27;amount&#x27;</span>].values.reshape(-<span class="number">1</span>,<span class="number">1</span>)</span><br><span class="line">std.fit(amount)</span><br><span class="line">RFM[<span class="string">&#x27;amount_std&#x27;</span>] = std.transform(amount)</span><br><span class="line"></span><br><span class="line"><span class="comment">#数据归一化</span></span><br><span class="line"><span class="keyword">from</span> sklearn <span class="keyword">import</span> preprocessing</span><br><span class="line">minmaxscaler = preprocessing.MinMaxScaler()</span><br><span class="line">amount = RFM[<span class="string">&#x27;amount&#x27;</span>].values.reshape(-<span class="number">1</span>,<span class="number">1</span>)</span><br><span class="line">minmaxscaler.fit(amount)</span><br><span class="line">RFM[<span class="string">&#x27;amount_range&#x27;</span>] = minmaxscaler.transform(amount)</span><br><span class="line">RFM.head(<span class="number">5</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">#log变换</span></span><br><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line">RFM[<span class="string">&#x27;amount_log&#x27;</span>] = np.log(RFM[<span class="string">&#x27;amount&#x27;</span>])</span><br><span class="line">RFM.head(<span class="number">5</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">#平方根变换</span></span><br><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line">RFM[<span class="string">&#x27;amount_sqrt&#x27;</span>] = np.sqrt(RFMN[<span class="string">&#x27;amount&#x27;</span>])</span><br><span class="line">RFM.head(<span class="number">5</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">#自定义区间离散化</span></span><br><span class="line">cut_points = [<span class="number">0</span>,<span class="number">200</span>,<span class="number">500</span>,<span class="number">800</span>,<span class="number">1000</span>]</span><br><span class="line">RFM[<span class="string">&#x27;amount_bin&#x27;</span>] = pd.cut(RFM[<span class="string">&#x27;amount&#x27;</span>],bins=cut_points)</span><br><span class="line">RFM.head(<span class="number">5</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">#等宽离散化</span></span><br><span class="line">RFM[<span class="string">&#x27;amount_width_bin&#x27;</span>] = pd.cut(RFM.amount,<span class="number">20</span>)</span><br><span class="line">RFM.head(<span class="number">5</span>)</span><br><span class="line"></span><br><span class="line">grouped = RFM.groupby(<span class="string">&#x27;amount_width_bin&#x27;</span>)</span><br><span class="line">grouped[<span class="string">&#x27;carid&#x27;</span>].count()</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">#等深离散化</span></span><br><span class="line">RFM[<span class="string">&#x27;amount_depth_bin&#x27;</span>] = pd.qcut(RFM.amount,<span class="number">20</span>)</span><br><span class="line">RFM.head(<span class="number">5</span>)</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>



<h3 id="模型构建"><a href="#模型构建" class="headerlink" title="模型构建"></a>模型构建</h3><h4 id="构建一个简单的分类模型"><a href="#构建一个简单的分类模型" class="headerlink" title="构建一个简单的分类模型"></a>构建一个简单的分类模型</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#预测titanic号上乘客生存概率</span></span><br><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"><span class="keyword">import</span> pandas <span class="keyword">as</span> pd</span><br><span class="line"><span class="keyword">from</span> sklearn.linear_model <span class="keyword">import</span> LogisticRegression</span><br><span class="line"><span class="keyword">from</span> sklearn <span class="keyword">import</span> metrics</span><br><span class="line"><span class="keyword">import</span> matplotlib.pyplot <span class="keyword">as</span> plt</span><br><span class="line">%matplotlib inline</span><br><span class="line"><span class="keyword">from</span> IPython.core.interactiveshell <span class="keyword">import</span> InteractiveShell</span><br><span class="line">InteractiveShell.ast_node_interactivity = <span class="string">&#x27;all&#x27;</span></span><br><span class="line"><span class="comment">#忽略告警提示</span></span><br><span class="line"><span class="keyword">import</span> warnings</span><br><span class="line">warnings.filterwarnings(<span class="string">&#x27;ignore&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">#1.读取数据</span></span><br><span class="line">train_src = pd.read_csv(<span class="string">&#x27;./train.csv&#x27;</span>)</span><br><span class="line">train_src.info()</span><br><span class="line">train_src.head()</span><br><span class="line"></span><br><span class="line"><span class="comment">#2.数据探索</span></span><br><span class="line"><span class="comment">#age分布</span></span><br><span class="line">train_src.hist(column=<span class="string">&#x27;age&#x27;</span>,biins=<span class="number">50</span>)</span><br><span class="line"><span class="comment">#性别分布</span></span><br><span class="line">train_src[<span class="string">&#x27;sex&#x27;</span>].value_counts().plot(kind=<span class="string">&#x27;bar&#x27;</span>)</span><br><span class="line"><span class="comment">#性别与目标（是否生存）的相关性</span></span><br><span class="line">pd.crosstab(train_src[<span class="string">&#x27;sex&#x27;</span>],train_src[<span class="string">&#x27;survived&#x27;</span>]).plot(kind=<span class="string">&#x27;bar&#x27;</span>)</span><br><span class="line"><span class="comment">#pclass与目标（是否生存）的相关性</span></span><br><span class="line">pd.crosstab(train_src[<span class="string">&#x27;pclass&#x27;</span>],train_src[<span class="string">&#x27;survived&#x27;</span>]).plot(kind=<span class="string">&#x27;bar&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">#3.数据准备</span></span><br><span class="line"><span class="comment">#挑选6个变量作为预测变量</span></span><br><span class="line">train = train_src[[<span class="string">&#x27;survived&#x27;</span>,<span class="string">&#x27;pclass&#x27;</span>,<span class="string">&#x27;sex&#x27;</span>,<span class="string">&#x27;age&#x27;</span>,<span class="string">&#x27;sibsp&#x27;</span>,<span class="string">&#x27;parch&#x27;</span>,<span class="string">&#x27;fare&#x27;</span>]]</span><br><span class="line"><span class="comment">#把sex变量的取值male替换为1，female替换为0</span></span><br><span class="line">train[<span class="string">&#x27;sex&#x27;</span>] = train[<span class="string">&#x27;sex&#x27;</span>].replace(&#123;<span class="string">&#x27;male&#x27;</span>:<span class="number">1</span>,<span class="string">&#x27;female&#x27;</span>:<span class="number">0</span>&#125;)</span><br><span class="line"><span class="comment">#有117个乘客age有缺失，用平均年龄替换</span></span><br><span class="line">age_mean = train[<span class="string">&#x27;age&#x27;</span>].mean()</span><br><span class="line">train[<span class="string">&#x27;age&#x27;</span>] = train[<span class="string">&#x27;age&#x27;</span>].fillna(age_mean)</span><br><span class="line"></span><br><span class="line">train.head(<span class="number">10</span>)</span><br><span class="line">train.describe()</span><br><span class="line"></span><br><span class="line"><span class="comment">#4.构建模型</span></span><br><span class="line"><span class="comment">#拆分出自然变量x，目标变量y</span></span><br><span class="line">train_X = train.ix[:,<span class="number">1</span>:] <span class="comment">#训练集自变量</span></span><br><span class="line">train_y = train[<span class="string">&#x27;survived&#x27;</span>] <span class="comment">#训练集因变量</span></span><br><span class="line"><span class="comment">#使用逻辑回归算法训练模型</span></span><br><span class="line">lr = LogisticRegression() <span class="comment">#使用默认参数</span></span><br><span class="line">lr.fit(train_X,train_y)   <span class="comment">#训练</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">#5.模型评估</span></span><br><span class="line">train_y_pred = lr.predict(train_X) <span class="comment">#对训练集进行预测，输出标签</span></span><br><span class="line">train_y_pred_prob= lr.predict_proba(train_X) <span class="comment">#对训练集进行预测，输出概率</span></span><br><span class="line"><span class="built_in">print</span> (train_y_pred)</span><br><span class="line"><span class="built_in">print</span> (train_y_pred_prob)</span><br><span class="line"></span><br><span class="line"><span class="comment">#误分类矩阵</span></span><br><span class="line">cnf_matrix = metrics.confusion_matrix(train_y,train_y_pred)</span><br><span class="line"><span class="built_in">print</span> (cnf_matrix)</span><br><span class="line"></span><br><span class="line"><span class="comment">#准确率</span></span><br><span class="line">precision = metrics.accuracy_score(train_y,train_y_pred)</span><br><span class="line"><span class="built_in">print</span>(precision)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">#更直观一点的展现误分类矩阵</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">show_confusion_matrix</span>(<span class="params">cnf_matrix,class_labels</span>):</span><br><span class="line">    plt.matshow(cnf_matrix,cmap=plt.cm.YLGn,alpha=<span class="number">0.7</span>)</span><br><span class="line">    ax = plt.gca()</span><br><span class="line">    ax.set_xlabel(<span class="string">&#x27;predicted label&#x27;</span>,fontsize=<span class="number">16</span>)</span><br><span class="line">    ax.set_xticks(<span class="built_in">range</span>(<span class="number">0</span>,<span class="built_in">len</span>(class_labels)))</span><br><span class="line">    ax.set_xticklabels(class_labels,rotation=<span class="number">45</span>)</span><br><span class="line">    ax.set_ylabel(<span class="string">&#x27;actual label&#x27;</span>,fontsize=<span class="number">16</span>,rotation=<span class="number">90</span>)</span><br><span class="line">    ax.set_yticks(<span class="built_in">range</span>(<span class="number">0</span>,<span class="built_in">len</span>(class_labels)))</span><br><span class="line">    ax.set_yticklabels(class_labels)</span><br><span class="line">    ax.xaxis.set_label_position(<span class="string">&#x27;top&#x27;</span>)</span><br><span class="line">    ax.xaxis.tick_top()</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span> row <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(cnf_matrix)):</span><br><span class="line">        <span class="keyword">for</span> col <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(cnf_matrix[row])):</span><br><span class="line">            ax.text(col,row,cnf_matrix[row][col],va=<span class="string">&#x27;center&#x27;</span>,ha=<span class="string">&#x27;center&#x27;</span>,fontsize=<span class="number">10</span>)</span><br><span class="line">            </span><br><span class="line"> class_labels = [<span class="number">0</span>,<span class="number">1</span>]</span><br><span class="line">show_confusion_matrix(cnf_matrix,class_labels)</span><br><span class="line"></span><br><span class="line"><span class="comment">#6.对新数据进行预测</span></span><br><span class="line">test_src = pd.read_csv()</span><br><span class="line">test = test_src[[<span class="string">&#x27;survived&#x27;</span>,<span class="string">&#x27;pclass&#x27;</span>,<span class="string">&#x27;sex&#x27;</span>,<span class="string">&#x27;age&#x27;</span>,<span class="string">&#x27;sibsp&#x27;</span>,<span class="string">&#x27;parch&#x27;</span>,<span class="string">&#x27;fare&#x27;</span>]]</span><br><span class="line">test[<span class="string">&#x27;sex&#x27;</span>].replace(&#123;<span class="string">&#x27;male&#x27;</span>:<span class="number">1</span>,<span class="string">&#x27;female&#x27;</span>:<span class="number">0</span>&#125;,inplace=<span class="literal">True</span>)</span><br><span class="line">test[<span class="string">&#x27;age&#x27;</span>].fillna(age_mean,inplace=<span class="literal">True</span>)</span><br><span class="line">test[<span class="string">&#x27;fare&#x27;</span>].fillna(<span class="built_in">round</span>(train[<span class="string">&#x27;fare&#x27;</span>].mean()),inplace=<span class="literal">True</span>)</span><br><span class="line"></span><br><span class="line">test.head()</span><br><span class="line"></span><br><span class="line"><span class="comment">#对测试数据预测</span></span><br><span class="line">test_X = test.ix[:,<span class="number">1</span>:]</span><br><span class="line">test_y_pred = lr.predict(test_X)</span><br><span class="line">test_pred = pd.DataFrame(&#123;<span class="string">&#x27;passengerid&#x27;</span>:test[<span class="string">&#x27;passengerid&#x27;</span>],<span class="string">&#x27;survived&#x27;</span>:test_y_pred.astype(<span class="built_in">int</span>)&#125;)</span><br><span class="line">test_pred.to_csv(<span class="string">&#x27;&#x27;</span>,index=<span class="literal">False</span>)</span><br><span class="line"></span><br><span class="line">test_pred.head()</span><br><span class="line"></span><br></pre></td></tr></table></figure>



<h4 id="用测试集对模型进行交叉验证"><a href="#用测试集对模型进行交叉验证" class="headerlink" title="用测试集对模型进行交叉验证"></a>用测试集对模型进行交叉验证</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> sklearn <span class="keyword">import</span> model_selection</span><br><span class="line">X_train,X_test,y_train,y_test = model_selection.train_test_split(train_X,train_y,test_size=<span class="number">0.3</span>,random_state=<span class="number">42</span>)</span><br><span class="line">lr = LogisticRegression()</span><br><span class="line">lr.fit(X_train,y_train)</span><br><span class="line"></span><br><span class="line"><span class="comment">#训练集验证准确率</span></span><br><span class="line">y_train_pre = lr.predict(X_train) <span class="comment">#对训练集进行预测</span></span><br><span class="line">metrics.accuracy_score(y_train,y_train_pre) <span class="comment">#训练集准确率</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#使用测试集验证模型</span></span><br><span class="line">y_test_pre = lr.predict(X_test) <span class="comment">#对测试集进行预测</span></span><br><span class="line">metrics.accuracy_score(y_test,y_test_pre) <span class="comment">#测试集准确率</span></span><br></pre></td></tr></table></figure>



<h4 id="关于分类的其他算法"><a href="#关于分类的其他算法" class="headerlink" title="关于分类的其他算法"></a>关于分类的其他算法</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> sklearn.linear_model <span class="keyword">import</span> LogisticRegression</span><br><span class="line"><span class="keyword">from</span> sklearn.svm <span class="keyword">import</span> SVC,LinearSVC</span><br><span class="line"><span class="keyword">from</span> sklearn.neighbors <span class="keyword">import</span> KNeighborsClassifier</span><br><span class="line"><span class="keyword">from</span> sklearn.tree <span class="keyword">import</span> DecisionTreeClassifier</span><br><span class="line"><span class="keyword">from</span> sklearn.ensemble <span class="keyword">import</span> RandomForestClassifier</span><br><span class="line"></span><br><span class="line"><span class="comment">#逻辑回归</span></span><br><span class="line">lr = LogisticRegression()</span><br><span class="line">lr.fit(X_train,y_train)</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;train accura:%f&quot;</span>%(lr.score(X_train,y_train)))</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;train accura:%f&quot;</span>%(lr.score(X_test,y_test)))</span><br><span class="line"></span><br><span class="line"><span class="comment">#向量机</span></span><br><span class="line">svc = SVC()</span><br><span class="line">svc.fit(X_train,y_train)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;train accura:%f&quot;</span>%(svc.score(X_train,y_train)))</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;train accura:%f&quot;</span>%(svc.score(X_test,y_test)))</span><br><span class="line"></span><br><span class="line"><span class="comment">#k近邻</span></span><br><span class="line">knn = KNeighborsClassifier(n_neighbors=<span class="number">3</span>)</span><br><span class="line">knn.fit(X_train,y_train)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;train accura:%f&quot;</span>%(knn.score(X_train,y_train)))</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;train accura:%f&quot;</span>%(knn.score(X_test,y_test)))</span><br><span class="line"></span><br><span class="line"><span class="comment">#决策树</span></span><br><span class="line">dtree = DecisionTreeClassifier()</span><br><span class="line">dtree.fit(X_train,y_train)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;train accura:%f&quot;</span>%(dtree.score(X_train,y_train)))</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;train accura:%f&quot;</span>%(dtree.score(X_test,y_test)))</span><br><span class="line"></span><br><span class="line"><span class="comment">#随机森林</span></span><br><span class="line">random_forest = RandomForestClassifier(n_estimators=<span class="number">10</span>)</span><br><span class="line">random_forest.fit(X_train,y_train)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;train accura:%f&quot;</span>%(random_forest.score(X_train,y_train)))</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;train accura:%f&quot;</span>%(random_forest.score(X_test,y_test)))</span><br></pre></td></tr></table></figure>

<h4 id="将多个模型的预测结果融合起来"><a href="#将多个模型的预测结果融合起来" class="headerlink" title="将多个模型的预测结果融合起来"></a>将多个模型的预测结果融合起来</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> sklearn.ensemble <span class="keyword">import</span> VotingClassifier  <span class="comment">#多模型投票融合器</span></span><br><span class="line"><span class="comment">#voting = &#x27;hard&#x27; 多数决定少数方式</span></span><br><span class="line"><span class="comment">#voting = &#x27;soft&#x27; 权重投票方式</span></span><br><span class="line">votingcf = VotingClassifier(estimators=[(<span class="string">&#x27;lr&#x27;</span>,lr),(<span class="string">&#x27;knn&#x27;</span>,knn),(<span class="string">&#x27;decisiontree&#x27;</span>,dtree),(<span class="string">&#x27;rf&#x27;</span>,random_forest),(<span class="string">&#x27;svm&#x27;</span>,svc),voting=<span class="string">&#x27;hard&#x27;</span>])</span><br><span class="line"></span><br><span class="line"><span class="comment">#训练集投票后的结果</span></span><br><span class="line">votingcf.fit(X_train,y_train)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;train accura:%f&quot;</span>%(votingcf.score(X_train,y_train)))</span><br><span class="line">votingcf.fit(X_test,y_test)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;train accura:%f&quot;</span>%(votingcf.score(X_test,y_test)))</span><br><span class="line"></span><br><span class="line"><span class="comment">#对新数据进行预测</span></span><br><span class="line">pred_y_pre = votingcf.predict(pred_X) <span class="number">3</span>对预测集进行预测</span><br><span class="line">submit = pd.DataFrame(&#123;<span class="string">&#x27;passengerid&#x27;</span>:pred_id,<span class="string">&#x27;survived&#x27;</span>:pred_y_pre.astype(<span class="built_in">int</span>)&#125;)</span><br><span class="line">submit.to_csv(<span class="string">&#x27;&#x27;</span>)</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h3 id="模型评估"><a href="#模型评估" class="headerlink" title="模型评估"></a>模型评估</h3><h4 id="偏差与方差"><a href="#偏差与方差" class="headerlink" title="偏差与方差"></a>偏差与方差</h4><ul>
<li>误差（error）：模型预测结果与真实结果之间的差异</li>
<li>偏差（bias）：模型的训练误差叫做偏差</li>
<li>方差（variance）：训练误差和测试误差的差异大小较方差</li>
</ul>
<h4 id="通过学习曲线诊断偏差和方差"><a href="#通过学习曲线诊断偏差和方差" class="headerlink" title="通过学习曲线诊断偏差和方差"></a>通过学习曲线诊断偏差和方差</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> sklearn.model_selection <span class="keyword">import</span> learning_curve</span><br><span class="line">svc = SVC()</span><br><span class="line">lr = LogisticRegrerssion()</span><br><span class="line">train_sizes,train_scores,test_scores = learning_curve(estimator=lr,X=train_X,y=train_y,train_sizes=np.linspace(<span class="number">0.1</span>,<span class="number">1.0</span>,<span class="number">10</span>),cv=<span class="number">5</span>,n_jobs=<span class="number">1</span>)</span><br><span class="line"><span class="comment">#计算训练集和测试集准确率的均值和标准差</span></span><br><span class="line">train_mean = np.mean(train_scores,axis=<span class="number">1</span>)</span><br><span class="line">train_std = np.std(train_scores,axis=<span class="number">1</span>)</span><br><span class="line">test_mean = np.mean(test_scores,axiis=<span class="number">1</span>)</span><br><span class="line">test_std = np.std(test_scores,axis=<span class="number">1</span>)</span><br><span class="line"><span class="comment">#对训练集的准确率作图</span></span><br><span class="line">plt.plot(train_sizes,train_mean,color=<span class="string">&#x27;blue&#x27;</span>,marker=<span class="string">&#x27;o&#x27;</span>,markersize=<span class="number">5</span>,label=<span class="string">&#x27;training accuracy&#x27;</span>)</span><br><span class="line"><span class="comment">#设置训练集准确率的可信范围</span></span><br><span class="line">plt.fill_between(train_sizes,train_mean + train_std,train_mean - train_std,alpha=<span class="number">0.15</span>,color=<span class="string">&#x27;blue&#x27;</span>)</span><br><span class="line"><span class="comment">#对测试集的准确率作图</span></span><br><span class="line">plt.plot(train_sizes,test_mean,color=<span class="string">&#x27;green&#x27;</span>,linestyle=<span class="string">&#x27;-&#x27;</span>,marker=<span class="string">&#x27;s&#x27;</span>,markersize=<span class="number">5</span>,label=<span class="string">&#x27;validation accuracy&#x27;</span>)</span><br><span class="line"><span class="comment">#设置测试集准确率的可信范围</span></span><br><span class="line">plt.fill_between(train_sizes,test_mean + test_std,test_mean - test_std,alpha=<span class="number">0.15</span>,color=<span class="string">&#x27;green&#x27;</span>)</span><br><span class="line"></span><br><span class="line">plt.grid()</span><br><span class="line">plt.xlabel(<span class="string">&#x27;Number of training samples&#x27;</span>)</span><br><span class="line">plt.ylabel(<span class="string">&#x27;Accuracy&#x27;</span>)</span><br><span class="line">plt.legend(loc=<span class="string">&#x27;lower right&#x27;</span>)</span><br><span class="line">plt.ylim([<span class="number">0.6</span>,<span class="number">1</span>])</span><br><span class="line">plt.tight_layout()</span><br><span class="line">plt.show()</span><br></pre></td></tr></table></figure>

<h4 id="通过验证曲线诊断过拟合和欠拟合"><a href="#通过验证曲线诊断过拟合和欠拟合" class="headerlink" title="通过验证曲线诊断过拟合和欠拟合"></a>通过验证曲线诊断过拟合和欠拟合</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> sklearn.model_selection <span class="keyword">import</span> validation_curve</span><br><span class="line">svc = SVC()</span><br><span class="line">lr = LogisticRegrerssion()</span><br><span class="line"><span class="comment">#模型复杂度的参数</span></span><br><span class="line">param_range = [<span class="number">0.0001</span>,<span class="number">0.001</span>,<span class="number">0.01</span>,<span class="number">0.1</span>,<span class="number">1.0</span>,<span class="number">10.0</span>,<span class="number">100.0</span>]</span><br><span class="line"></span><br><span class="line">train_scores,test_scores = validation_curve(estimator=svc,X=train_X,y=train_y,param_name=<span class="string">&#x27;C&#x27;</span>,param_range=param_range,cv=<span class="number">10</span>)</span><br><span class="line"><span class="comment">#计算训练集和测试集准确率的均值和标准差</span></span><br><span class="line">train_mean = np.mean(train_scores,axis=<span class="number">1</span>)</span><br><span class="line">train_std = np.std(train_scores,axis=<span class="number">1</span>)</span><br><span class="line">test_mean = np.mean(test_scores,axiis=<span class="number">1</span>)</span><br><span class="line">test_std = np.std(test_scores,axis=<span class="number">1</span>)</span><br><span class="line"><span class="comment">#对训练集的准确率作图</span></span><br><span class="line">plt.plot(param_range,train_mean,color=<span class="string">&#x27;blue&#x27;</span>,marker=<span class="string">&#x27;o&#x27;</span>,markersize=<span class="number">5</span>,label=<span class="string">&#x27;training accuracy&#x27;</span>)</span><br><span class="line"><span class="comment">#设置训练集准确率的可信范围</span></span><br><span class="line">plt.fill_between(param_range,train_mean + train_std,train_mean - train_std,alpha=<span class="number">0.15</span>,color=<span class="string">&#x27;blue&#x27;</span>)</span><br><span class="line"><span class="comment">#对测试集的准确率作图</span></span><br><span class="line">plt.plot(param_range,test_mean,color=<span class="string">&#x27;green&#x27;</span>,linestyle=<span class="string">&#x27;-&#x27;</span>,marker=<span class="string">&#x27;s&#x27;</span>,markersize=<span class="number">5</span>,label=<span class="string">&#x27;validation accuracy&#x27;</span>)</span><br><span class="line"><span class="comment">#设置测试集准确率的可信范围</span></span><br><span class="line">plt.fill_between(param_range,test_mean + test_std,test_mean - test_std,alpha=<span class="number">0.15</span>,color=<span class="string">&#x27;green&#x27;</span>)</span><br><span class="line"></span><br><span class="line">plt.grid()</span><br><span class="line">plt.xlabel(<span class="string">&#x27;Number of training samples&#x27;</span>)</span><br><span class="line">plt.ylabel(<span class="string">&#x27;Accuracy&#x27;</span>)</span><br><span class="line">plt.legend(loc=<span class="string">&#x27;lower right&#x27;</span>)</span><br><span class="line">plt.ylim([<span class="number">0.6</span>,<span class="number">1</span>])</span><br><span class="line">plt.tight_layout()</span><br><span class="line">plt.show()</span><br></pre></td></tr></table></figure>

<h4 id="数据集划分"><a href="#数据集划分" class="headerlink" title="数据集划分"></a>数据集划分</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> sklearn.model_selection <span class="keyword">import</span> train_test_split</span><br><span class="line"><span class="comment">#把数据集拆分成训练集和测试集</span></span><br><span class="line">X_train,X_test,y_train,y_test = train_test_split(train_X,train_y,test_size=<span class="number">0.3</span>,random_state=<span class="number">42</span>)</span><br></pre></td></tr></table></figure>

<p>K折交叉验证</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> sklearn.model_selection <span class="keyword">import</span> cross_val_score</span><br><span class="line">lr = LogisticRegression()</span><br><span class="line"><span class="comment">#用k折交叉验证方法来验证模型准确率</span></span><br><span class="line">cross_val_score(lr,train_X,train_y,cv=<span class="number">5</span>)</span><br><span class="line">cross_val_score(lr,train_X,train_y,cv=<span class="number">5</span>).mean()</span><br></pre></td></tr></table></figure>

<h4 id="准确率和召回率"><a href="#准确率和召回率" class="headerlink" title="准确率和召回率"></a>准确率和召回率</h4><h4 id="收益曲线"><a href="#收益曲线" class="headerlink" title="收益曲线"></a>收益曲线</h4><h4 id="ROC与AUC"><a href="#ROC与AUC" class="headerlink" title="ROC与AUC"></a>ROC与AUC</h4><h4 id="ks值"><a href="#ks值" class="headerlink" title="ks值"></a>ks值</h4><h3 id="常用算法解析"><a href="#常用算法解析" class="headerlink" title="常用算法解析"></a>常用算法解析</h3><h4 id="逻辑回归"><a href="#逻辑回归" class="headerlink" title="逻辑回归"></a>逻辑回归</h4><h4 id="k近邻"><a href="#k近邻" class="headerlink" title="k近邻"></a>k近邻</h4><h4 id="决策树"><a href="#决策树" class="headerlink" title="决策树"></a>决策树</h4><h4 id="向量机"><a href="#向量机" class="headerlink" title="向量机"></a>向量机</h4><h4 id="贝叶斯公式"><a href="#贝叶斯公式" class="headerlink" title="贝叶斯公式"></a>贝叶斯公式</h4><h4 id="线性回归"><a href="#线性回归" class="headerlink" title="线性回归"></a>线性回归</h4><h4 id="聚类分析"><a href="#聚类分析" class="headerlink" title="聚类分析"></a>聚类分析</h4><h4 id="关联分析"><a href="#关联分析" class="headerlink" title="关联分析"></a>关联分析</h4><h3 id="传统图像特征提取法构建分类模型"><a href="#传统图像特征提取法构建分类模型" class="headerlink" title="传统图像特征提取法构建分类模型"></a>传统图像特征提取法构建分类模型</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"><span class="keyword">import</span> cv2</span><br><span class="line"><span class="keyword">import</span> os</span><br><span class="line"><span class="keyword">from</span> sklearn.model_selection <span class="keyword">import</span> train_test_split</span><br><span class="line"><span class="keyword">from</span> sklearn.preprocessing <span class="keyword">import</span> LabelEncoder</span><br><span class="line"><span class="keyword">from</span> sklearn.ensemble <span class="keyword">import</span> RandomForestClassifier</span><br><span class="line"><span class="keyword">from</span> sklearn.linear_model <span class="keyword">import</span> LogisticRegression</span><br><span class="line"><span class="keyword">from</span> sklearn.metrics <span class="keyword">import</span> confusion_matrix,precision_recall_fscore_support</span><br><span class="line"><span class="keyword">import</span> pandas <span class="keyword">as</span> pd</span><br><span class="line"><span class="keyword">import</span> pickle</span><br><span class="line"></span><br><span class="line">output_dir = <span class="string">&#x27;output&#x27;</span></span><br><span class="line"><span class="keyword">if</span> <span class="keyword">not</span> os.path.exists(output_dir):</span><br><span class="line">    os.mkdir(output_dir)</span><br><span class="line"> <span class="comment">#1.数据准备   </span></span><br><span class="line">image_dir = <span class="string">&#x27;./&#x27;</span></span><br><span class="line"></span><br><span class="line">images = []</span><br><span class="line">labels = []</span><br><span class="line"><span class="keyword">for</span> fname <span class="keyword">in</span> os.listdir(image_dir):</span><br><span class="line">    <span class="comment">#跳过不是目标图片的文件</span></span><br><span class="line">    <span class="keyword">if</span> <span class="keyword">not</span> fname.startswith(<span class="string">&#x27;image&#x27;</span>):<span class="keyword">continue</span></span><br><span class="line">    fpath = os.path.join(image_dir,fname)</span><br><span class="line">    <span class="comment">#根据文件名，提取图片分类</span></span><br><span class="line">    lab = fpath.split(<span class="string">&#x27;_&#x27;</span>)[<span class="number">1</span>]</span><br><span class="line">    <span class="comment">#rgb模式读取图片</span></span><br><span class="line">    img = cv2.imread(fpath,cv2.IMREAD_COLOR)</span><br><span class="line">    images.append(img)</span><br><span class="line">    labels.append(lab)</span><br><span class="line">    </span><br><span class="line"><span class="comment">#将图片标签ID化</span></span><br><span class="line">label_encoder = LabelEncoder()</span><br><span class="line">y = label_encoder.fit_transform(labels)</span><br><span class="line"><span class="comment">#训练集，测试集划分</span></span><br><span class="line">train_idx,test_idx = train_test_split(<span class="built_in">range</span>(<span class="built_in">len</span>(y)),test_size=<span class="number">0.2</span>,stratify=y,random_state=<span class="number">1234</span>)</span><br><span class="line">train_y = y[train_idx]</span><br><span class="line">test_y = y[test_idx]</span><br><span class="line"></span><br><span class="line"><span class="comment">#2.使用RGB颜色直方图做特征训练分类器</span></span><br><span class="line"><span class="comment">#定义特征转化函数</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">transform</span>(<span class="params">img</span>):</span><br><span class="line">    <span class="comment">#每个通道等分为8组后计算直方图</span></span><br><span class="line">    hist = cv2.calcHist([img],[<span class="number">0</span>,<span class="number">1</span>,<span class="number">2</span>],<span class="literal">None</span>,[<span class="number">8</span>]*<span class="number">3</span>,[<span class="number">0</span>,<span class="number">256</span>]*<span class="number">3</span>)</span><br><span class="line">    <span class="comment">#将8x8x8的多维数组拉平</span></span><br><span class="line">    <span class="keyword">return</span> hist.ravel()</span><br><span class="line"></span><br><span class="line"><span class="comment">#提取每个图像的直方图特征</span></span><br><span class="line">x = np.row_stack([transform(img) <span class="keyword">for</span> img <span class="keyword">in</span> images])</span><br><span class="line"></span><br><span class="line">train_x = x[train_idx,:]</span><br><span class="line">test_x = x[test_idx,:]</span><br><span class="line"></span><br><span class="line"><span class="comment">#使用随机森林训练分类器</span></span><br><span class="line"><span class="comment">#RandomForestClassifier</span></span><br><span class="line"><span class="comment">#n_estimators:整数，书的个数，默认10，树越多拟合效果越好，也越容易拟合</span></span><br><span class="line"><span class="comment">#criterion:衡量树的某次分裂好坏的指标，可选值有&#123;&#x27;gini&#x27;,&#x27;entropy&#x27;&#125;</span></span><br><span class="line"><span class="comment">#max_features:寻找最佳分裂时最多使用多少个特征</span></span><br><span class="line"><span class="comment">#max_depth:int或None,每个树最大的深度。默认None,表示每个树节点会一直分裂直到所有</span></span><br><span class="line"><span class="comment">#min_samples_split:默认为2，对一个节点进行分裂时，至少需要这么多样本</span></span><br><span class="line"><span class="comment">#min_samples_leaf:默认为1，叶子节点至少需要这么多样本</span></span><br><span class="line">model = RandomForestClassifier(n_estimators=<span class="number">15</span>,max_depth=<span class="number">3</span>,random_state=<span class="number">1234</span>)</span><br><span class="line">model.fit(train_x,train_y)</span><br><span class="line"></span><br><span class="line"><span class="comment">#保存模型</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">save_model</span>(<span class="params">model,label_encoder,output_file</span>):</span><br><span class="line">    <span class="keyword">try</span>:</span><br><span class="line">        <span class="keyword">with</span> <span class="built_in">open</span>(output_file,<span class="string">&#x27;wb&#x27;</span>) <span class="keyword">as</span> outfile:</span><br><span class="line">            pickle.dump(&#123;</span><br><span class="line">                <span class="string">&#x27;model&#x27;</span>:model,</span><br><span class="line">                <span class="string">&#x27;label_encoder&#x27;</span>:label_encoder</span><br><span class="line">            &#125;,outfile)</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line">        <span class="keyword">except</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">        </span><br><span class="line">save_model(model,label_encoder,os.path.join(output_dir,<span class="string">&#x27;model_rf1.pkl&#x27;</span>))</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">#评估随机森林分类器</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">eval_model</span>(<span class="params">y_true,y_pred,labels</span>):</span><br><span class="line">    <span class="comment">#计算每个分类的precision,recall,f1,support</span></span><br><span class="line">    p,r,f1,s = precision_recall_support(y_true,y_pred)</span><br><span class="line">    <span class="comment">#计算总体的平均precision,recall,f1,support</span></span><br><span class="line">    tot_p = np.average(p,weights=s)</span><br><span class="line">    tot_r = np.average(r,weights=s)</span><br><span class="line">    tot_f1 = np.average(f1,weights=s)</span><br><span class="line">    tot_s = np.<span class="built_in">sum</span>(s)</span><br><span class="line">    res1 = pd.DataFrame(&#123;</span><br><span class="line">        <span class="string">u&#x27;Label&#x27;</span>:labels,</span><br><span class="line">        <span class="string">u&#x27;Precision&#x27;</span>:p,</span><br><span class="line">        <span class="string">u&#x27;Recall&#x27;</span>:r,</span><br><span class="line">        <span class="string">u&#x27;F1&#x27;</span>:f1,</span><br><span class="line">        <span class="string">u&#x27;Support&#x27;</span>:s,</span><br><span class="line">    &#125;)</span><br><span class="line">    res2 = pd.DataFrame(&#123;</span><br><span class="line">         <span class="string">u&#x27;Label&#x27;</span>:[<span class="string">u&#x27;总体&#x27;</span>],</span><br><span class="line">        <span class="string">u&#x27;Precision&#x27;</span>:[tot_p],</span><br><span class="line">        <span class="string">u&#x27;Recall&#x27;</span>:[tot_r],</span><br><span class="line">        <span class="string">u&#x27;F1&#x27;</span>:[tot_f1],</span><br><span class="line">        <span class="string">u&#x27;Support&#x27;</span>:[tot_s],</span><br><span class="line">    &#125;)</span><br><span class="line">    res2.index = [<span class="number">999</span>]</span><br><span class="line">    res = pd.concat([res1,res2])</span><br><span class="line">    <span class="comment">#计算混淆矩阵</span></span><br><span class="line">    conf_mat = pd.DataFrame(confusion_matrix(y_true,y_pred),columns=labels,index=labels)</span><br><span class="line">    <span class="keyword">return</span> conf_mat,res[[<span class="string">u&#x27;Label&#x27;</span>,<span class="string">u&#x27;Precision&#x27;</span>,<span class="string">u&#x27;Recall&#x27;</span>,<span class="string">u&#x27;F1&#x27;</span>,<span class="string">u&#x27;Support&#x27;</span>]]</span><br><span class="line"></span><br><span class="line"><span class="comment">#在测试集上计算每个图片的预测分类</span></span><br><span class="line">y_pred = model.predict(test_x)</span><br><span class="line"><span class="comment">#评估模型</span></span><br><span class="line">conf_mat,evalues = eval_model(test_y,y_pred,label_encoder.classes_)</span><br><span class="line"><span class="comment">#混淆矩阵</span></span><br><span class="line">conf_mat</span><br><span class="line"><span class="comment">#各项评价指标</span></span><br><span class="line">evalues</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">#使用逻辑回归训练分类器</span></span><br><span class="line">model = LogisticRegression(penalty=<span class="string">&#x27;12&#x27;</span>,C=<span class="number">1</span>,random_state=<span class="number">1234</span>)</span><br><span class="line">model.fit(train_x,train_y)</span><br><span class="line">save_model(model,label_encoder,os.path.join(output_dir,<span class="string">&#x27;model_rf1.pkl&#x27;</span>))</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">#对新图片进行分类</span></span><br><span class="line"><span class="comment">#定义一个用于分类的predictor类</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Predictor</span>(<span class="title class_ inherited__">object</span>):</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self,model_file</span>):</span><br><span class="line">        <span class="keyword">with</span> <span class="built_in">open</span>(model_file,<span class="string">&#x27;rb&#x27;</span>) <span class="keyword">as</span> infile:</span><br><span class="line">            <span class="variable language_">self</span>.loaded = pickle.load(infile)</span><br><span class="line">        <span class="variable language_">self</span>.model = <span class="variable language_">self</span>.loaded[<span class="string">&#x27;model&#x27;</span>]</span><br><span class="line">        <span class="variable language_">self</span>.label_encoder = <span class="variable language_">self</span>.loaded[<span class="string">&#x27;label_encoder&#x27;</span>]</span><br><span class="line">        </span><br><span class="line">     <span class="comment">#实现分类逻辑</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">predict</span>(<span class="params">self,img_file</span>):</span><br><span class="line">        img = cv2.imread(img_file,cv2.IMREAD_COLOR)</span><br><span class="line">        img = cv2.cvtColor(img,cv2.COLOR_BGR2LAB)</span><br><span class="line">        X = cv2.calcHist([img],[<span class="number">0</span>,<span class="number">1</span>,<span class="number">2</span>],<span class="literal">None</span>,[<span class="number">8</span>]*<span class="number">3</span>,[<span class="number">0</span>,<span class="number">256</span>]*<span class="number">3</span>)</span><br><span class="line">        y = <span class="variable language_">self</span>.model.predict(x)</span><br><span class="line">        label = <span class="variable language_">self</span>.label_encoder.inverse_transform(y)</span><br><span class="line">        <span class="keyword">return</span> label</span><br><span class="line">    </span><br><span class="line">    predictor = Predictor(os.path.join(output_dir,<span class="string">&#x27;model_rf2.pkl&#x27;</span>))</span><br><span class="line">    </span><br><span class="line">    <span class="comment">#对新图片进行分类</span></span><br><span class="line">    predictor.predict(<span class="string">&#x27;./00.png&#x27;</span>)</span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line">                    </span><br><span class="line"></span><br></pre></td></tr></table></figure>



<h3 id="python处理DICOM图像方法"><a href="#python处理DICOM图像方法" class="headerlink" title="python处理DICOM图像方法"></a>python处理DICOM图像方法</h3><p>SimpleITK,pydicom</p>

      </div>
      
      
      
    </div>
    

    
    
    


          </div>
          

<script>
  window.addEventListener('tabs:register', () => {
    let { activeClass } = CONFIG.comments;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      let activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      let commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>

        </div>
          
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line toggle-line-first"></span>
    <span class="toggle-line toggle-line-middle"></span>
    <span class="toggle-line toggle-line-last"></span>
  </div>

  <aside class="sidebar">
    <div class="sidebar-inner">

      <ul class="sidebar-nav motion-element">
        <li class="sidebar-nav-toc">
          Table of Contents
        </li>
        <li class="sidebar-nav-overview">
          Overview
        </li>
      </ul>

      <!--noindex-->
      <div class="post-toc-wrap sidebar-panel">
      </div>
      <!--/noindex-->

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
  <p class="site-author-name" itemprop="name">zw</p>
  <div class="site-description" itemprop="description">zw的个人博客</div>
</div>
<div class="site-state-wrap motion-element">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives/">
        
          <span class="site-state-item-count">20</span>
          <span class="site-state-item-name">posts</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
        <span class="site-state-item-count">1</span>
        <span class="site-state-item-name">categories</span>
      </div>
      <div class="site-state-item site-state-tags">
        <span class="site-state-item-count">12</span>
        <span class="site-state-item-name">tags</span>
      </div>
  </nav>
</div>



      </div>

    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer class="footer">
      <div class="footer-inner">
        

        

<div class="copyright">
  
  &copy; 
  <span itemprop="copyrightYear">2024</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">zw</span>
</div>
  <div class="powered-by">Powered by <a href="https://hexo.io/" class="theme-link" rel="noopener" target="_blank">Hexo</a> & <a href="https://muse.theme-next.org/" class="theme-link" rel="noopener" target="_blank">NexT.Muse</a>
  </div>

        








      </div>
    </footer>
  </div>

  
  <script src="/lib/anime.min.js"></script>
  <script src="/lib/velocity/velocity.min.js"></script>
  <script src="/lib/velocity/velocity.ui.min.js"></script>

<script src="/js/utils.js"></script>

<script src="/js/motion.js"></script>


<script src="/js/schemes/muse.js"></script>


<script src="/js/next-boot.js"></script>




  















  

  

</body>
</html>
